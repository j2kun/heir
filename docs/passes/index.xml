<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>HEIR â€“ Passes</title><link>https://heir.dev/docs/passes/</link><description>Recent content in Passes on HEIR</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://heir.dev/docs/passes/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: BGVToPolynomial</title><link>https://heir.dev/docs/passes/bgvtopolynomial/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/passes/bgvtopolynomial/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="-bgv-to-polynomial">&lt;code>-bgv-to-polynomial&lt;/code>&lt;/h3>
&lt;p>&lt;em>Lower &lt;code>bgv&lt;/code> to &lt;code>polynomial&lt;/code> dialect.&lt;/em>&lt;/p>
&lt;p>This pass lowers the &lt;code>bgv&lt;/code> dialect to &lt;code>polynomial&lt;/code> dialect.&lt;/p></description></item><item><title>Docs: CGGIPasses</title><link>https://heir.dev/docs/passes/cggipasses/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/passes/cggipasses/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="-cggi-set-default-parameters">&lt;code>-cggi-set-default-parameters&lt;/code>&lt;/h3>
&lt;p>&lt;em>Set default parameters for CGGI ops&lt;/em>&lt;/p>
&lt;p>This pass adds default parameters to all CGGI ops as &lt;code>cggi_params&lt;/code> named
attributes, overriding any existing attribute set with that name.&lt;/p>
&lt;p>This pass is primarily for testing purposes, and as a parameter provider
before a proper parameter selection mechanism is added. This pass should not
be used in production.&lt;/p>
&lt;p>The specific parameters are hard-coded in
&lt;code>lib/Dialect/CGGI/Transforms/SetDefaultParameters.cpp&lt;/code>.&lt;/p>
&lt;h3 id="-cggi-straight-line-vectorizer">&lt;code>-cggi-straight-line-vectorizer&lt;/code>&lt;/h3>
&lt;p>&lt;em>A straight-line vectorizer for CGGI bootstrapping ops.&lt;/em>&lt;/p>
&lt;p>This pass vectorizes CGGI ops. It ignores control flow and only vectorizes
straight-line programs within a given region.&lt;/p></description></item><item><title>Docs: CGGIToTfheRust</title><link>https://heir.dev/docs/passes/cggitotfherust/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/passes/cggitotfherust/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="-cggi-to-tfhe-rust">&lt;code>-cggi-to-tfhe-rust&lt;/code>&lt;/h3>
&lt;p>&lt;em>Lower &lt;code>cggi&lt;/code> to &lt;code>tfhe_rust&lt;/code> dialect.&lt;/em>&lt;/p></description></item><item><title>Docs: CombToCGGI</title><link>https://heir.dev/docs/passes/combtocggi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/passes/combtocggi/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="-comb-to-cggi">&lt;code>-comb-to-cggi&lt;/code>&lt;/h3>
&lt;p>&lt;em>Lower &lt;code>comb&lt;/code> to &lt;code>cggi&lt;/code> dialect.&lt;/em>&lt;/p>
&lt;p>This pass lowers the &lt;code>comb&lt;/code> dialect to &lt;code>cggi&lt;/code> dialect.&lt;/p></description></item><item><title>Docs: ForwardStoreToLoadPasses</title><link>https://heir.dev/docs/passes/forwardstoretoloadpasses/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/passes/forwardstoretoloadpasses/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="-forward-store-to-load">&lt;code>-forward-store-to-load&lt;/code>&lt;/h3>
&lt;p>&lt;em>Forward stores to loads within a single block&lt;/em>&lt;/p>
&lt;p>This pass is a simplified version of mem2reg and similar passes.
It analyzes an operation, finding all basic blocks within that op
that have memrefs whose stores can be forwarded to loads.&lt;/p>
&lt;p>Does not support complex control flow within a block, nor ops
with arbitrary subregions.&lt;/p></description></item><item><title>Docs: LWEPasses</title><link>https://heir.dev/docs/passes/lwepasses/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/passes/lwepasses/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="-lwe-set-default-parameters">&lt;code>-lwe-set-default-parameters&lt;/code>&lt;/h3>
&lt;p>&lt;em>Set default parameters for LWE ops&lt;/em>&lt;/p>
&lt;p>This pass adds default parameters to all &lt;code>lwe&lt;/code> types as the &lt;code>lwe_params&lt;/code>
attribute, and for &lt;code>lwe&lt;/code> ops as the &lt;code>params&lt;/code> attribute, overriding any
existing attributes set with those names.&lt;/p>
&lt;p>This pass is primarily for testing purposes, and as a parameter provider
before a proper parameter selection mechanism is added. This pass should not
be used in production.&lt;/p>
&lt;p>The specific parameters are hard-coded in
&lt;code>lib/Dialect/LWE/Transforms/SetDefaultParameters.cpp&lt;/code>.&lt;/p></description></item><item><title>Docs: MemrefToArith</title><link>https://heir.dev/docs/passes/memreftoarith/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/passes/memreftoarith/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="-expand-copy">&lt;code>-expand-copy&lt;/code>&lt;/h3>
&lt;p>&lt;em>Expands memref.copy ops to explicit affine loads and stores&lt;/em>&lt;/p>
&lt;p>This pass removes memref copy operations by expanding them to affine loads
and stores. This pass introduces affine loops over the dimensions of the
MemRef, so must be run prior to any affine loop unrolling in a pipeline.&lt;/p>
&lt;p>Input&lt;/p>
&lt;pre tabindex="0">&lt;code>module {
func.func @memref_copy() {
%alloc = memref.alloc() : memref&amp;lt;2x3xi32&amp;gt;
%alloc_0 = memref.alloc() : memref&amp;lt;2x3xi32&amp;gt;
memref.copy %alloc, %alloc_0 : memref&amp;lt;1x1xi32&amp;gt; to memref&amp;lt;1x1xi32&amp;gt;
}
}
&lt;/code>&lt;/pre>&lt;p>Output&lt;/p>
&lt;pre tabindex="0">&lt;code>module {
func.func @memref_copy() {
%alloc = memref.alloc() : memref&amp;lt;2x3xi32&amp;gt;
%alloc_0 = memref.alloc() : memref&amp;lt;2x3xi32&amp;gt;
affine.for %arg0 = 0 to 2 {
affine.for %arg1 = 0 to 3 {
%1 = affine.load %alloc[%arg0, %arg1] : memref&amp;lt;2x3xi32&amp;gt;
affine.store %1, %alloc_0[%arg0, %arg1] : memref&amp;lt;2x3xi32&amp;gt;
}
}
}
}
&lt;/code>&lt;/pre>&lt;h3 id="-extract-loop-body">&lt;code>-extract-loop-body&lt;/code>&lt;/h3>
&lt;p>&lt;em>Extracts logic of a loop bodies into functions.&lt;/em>&lt;/p>
&lt;p>This pass extracts logic in the inner body of for loops into functions.&lt;/p>
&lt;p>This pass requires that tensors are lowered to memref. It expects that a
loop body contains a number of affine.load statements used as inputs to the
extracted function, and a single affine.store used as the extracted
function&amp;rsquo;s output.&lt;/p>
&lt;p>Input&lt;/p>
&lt;pre tabindex="0">&lt;code>module {
func.func @loop_body() {
%c-128_i8 = arith.constant -128 : i8
%c127_i8 = arith.constant 127 : i8
%alloc_7 = memref.alloc() {alignment = 64 : i64} : memref&amp;lt;25x20x8xi8&amp;gt;
affine.for %arg1 = 0 to 25 {
affine.for %arg2 = 0 to 20 {
affine.for %arg3 = 0 to 8 {
%98 = affine.load %alloc_6[%arg1, %arg2, %arg3] : memref&amp;lt;25x20x8xi8&amp;gt;
%99 = arith.cmpi slt, %arg0, %c-128_i8 : i8
%100 = arith.select %99, %c-128_i8, %arg0 : i8
%101 = arith.cmpi sgt, %arg0, %c127_i8 : i8
%102 = arith.select %101, %c127_i8, %100 : i8
affine.store %102, %alloc_7[%arg1, %arg2, %arg3] : memref&amp;lt;25x20x8xi8&amp;gt;
}
}
}
}
}
&lt;/code>&lt;/pre>&lt;p>Output&lt;/p>
&lt;pre tabindex="0">&lt;code>module {
func.func @loop_body() {
%alloc_7 = memref.alloc() {alignment = 64 : i64} : memref&amp;lt;25x20x8xi8&amp;gt;
affine.for %arg1 = 0 to 25 {
affine.for %arg2 = 0 to 20 {
affine.for %arg3 = 0 to 8 {
%98 = affine.load %alloc_6[%arg1, %arg2, %arg3] : memref&amp;lt;25x20x8xi8&amp;gt;
%102 = func.call @__for_loop(%98) : (i8) -&amp;gt; i8
affine.store %102, %alloc_7[%arg1, %arg2, %arg3] : memref&amp;lt;25x20x8xi8&amp;gt;
}
}
}
}
func.func private @__for_loop(%arg0: i8) -&amp;gt; i8 {
%c-128_i8 = arith.constant -128 : i8
%c127_i8 = arith.constant 127 : i8
%99 = arith.cmpi slt, %arg0, %c-128_i8 : i8
%100 = arith.select %99, %c-128_i8, %arg0 : i8
%101 = arith.cmpi sgt, %arg0, %c127_i8 : i8
%102 = arith.select %101, %c127_i8, %100 : i8
return %102 : i8
}
}
&lt;/code>&lt;/pre>&lt;h4 id="options">Options&lt;/h4>
&lt;pre tabindex="0">&lt;code>-min-loop-size : Use this to control the minimum loop size to apply this pass
-min-body-size : Use this to control the minimum loop body size to apply this pass
&lt;/code>&lt;/pre>&lt;h3 id="-memref-global-replace">&lt;code>-memref-global-replace&lt;/code>&lt;/h3>
&lt;p>&lt;em>MemrefGlobalReplacePass forwards global memrefs accessors to arithmetic values&lt;/em>&lt;/p>
&lt;p>This pass forwards constant global MemRef values to referencing affine
loads. This pass requires that the MemRef global values are initialized as
constants and that the affine load access indices are constants (i.e. not
variadic). Unroll affine loops prior to running this pass.&lt;/p>
&lt;p>MemRef removal is required to remove any memory allocations from the input
model (for example, TensorFlow models contain global memory holding model
weights) to support FHE transpilation.&lt;/p>
&lt;p>Input&lt;/p>
&lt;pre tabindex="0">&lt;code>module {
memref.global &amp;#34;private&amp;#34; constant @__constant_8xi16 : memref&amp;lt;2x4xi16&amp;gt; = dense&amp;lt;[[-10, 20, 3, 4], [5, 6, 7, 8]]&amp;gt;
func.func @main() -&amp;gt; i16 {
%c1 = arith.constant 1 : index
%c2 = arith.constant 2 : index
%0 = memref.get_global @__constant_8xi16 : memref&amp;lt;2x4xi16&amp;gt;
%1 = affine.load %0[%c1, %c1 + %c2] : memref&amp;lt;2x4xi16&amp;gt;
return %1 : i16
}
}
&lt;/code>&lt;/pre>&lt;p>Output&lt;/p>
&lt;pre tabindex="0">&lt;code>module {
func.func @main() -&amp;gt; i16 {
%c1 = arith.constant 1 : index
%c2 = arith.constant 2 : index
%c8_i16 = arith.constant 8 : i16
return %c8_i16 : i16
}
}
&lt;/code>&lt;/pre>&lt;h3 id="-unroll-and-forward">&lt;code>-unroll-and-forward&lt;/code>&lt;/h3>
&lt;p>&lt;em>Loop unrolls and forwards stores to loads.&lt;/em>&lt;/p>
&lt;p>This pass processes the first function in a given module, and, starting from
the first loop, iteratively does the following:&lt;/p>
&lt;ol>
&lt;li>Fully unroll the loop.&lt;/li>
&lt;li>Scan for load ops. For each load op with a statically-inferrable access
index:&lt;/li>
&lt;li>Backtrack to the original memref alloc&lt;/li>
&lt;li>Find all store ops at the corresponding index (possibly transitively
through renames/subviews of the underlying alloc).&lt;/li>
&lt;li>Find the last store that occurs and forward it to the load.&lt;/li>
&lt;li>If the original memref is an input memref, then forward through any
renames to make the target load load directly from the argument memref
(instead of any subviews, say)&lt;/li>
&lt;li>Apply the same logic to any remaining loads not inside any for loop.&lt;/li>
&lt;/ol>
&lt;p>This pass requires that tensors are lowered to memref, and only supports
affine loops with affine.load/store ops.&lt;/p>
&lt;p>Memrefs that result from memref.get_global ops are excluded from
forwarding, even if they are loaded with a static index, and are instead
handled by memref-global-replace, which should be run after this pass.&lt;/p></description></item><item><title>Docs: PolynomialToStandard</title><link>https://heir.dev/docs/passes/polynomialtostandard/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/passes/polynomialtostandard/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="-polynomial-to-standard">&lt;code>-polynomial-to-standard&lt;/code>&lt;/h3>
&lt;p>&lt;em>Lower &lt;code>polynomial&lt;/code> to standard MLIR dialects.&lt;/em>&lt;/p>
&lt;p>This pass lowers the &lt;code>polynomial&lt;/code> dialect to standard MLIR, a mixture of
affine, tensor, and arith.&lt;/p></description></item><item><title>Docs: SecretizePasses</title><link>https://heir.dev/docs/passes/secretizepasses/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/passes/secretizepasses/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="-secretize">&lt;code>-secretize&lt;/code>&lt;/h3>
&lt;p>&lt;em>Adds secret argument attributes to entry function&lt;/em>&lt;/p>
&lt;p>Adds a secret.secret attribute argument to each argument in the entry
function of an MLIR module. By default, the function is &lt;code>main&lt;/code>. This may be
overridden with the option -entry-function=top_level_func.&lt;/p>
&lt;h4 id="options">Options&lt;/h4>
&lt;pre tabindex="0">&lt;code>-entry-function : entry function of the module
&lt;/code>&lt;/pre>&lt;h3 id="-wrap-generic">&lt;code>-wrap-generic&lt;/code>&lt;/h3>
&lt;p>&lt;em>Wraps regions using secret args in secret.generic bodies&lt;/em>&lt;/p>
&lt;p>This pass wraps function regions of &lt;code>func.func&lt;/code> that use secret arguments in
&lt;code>secret.generic&lt;/code> bodies.&lt;/p>
&lt;p>Secret arguments are annotated using a &lt;code>secret.secret&lt;/code> argument attribute.
This pass converts these to secret types and then inserts a &lt;code>secret.generic&lt;/code>
body to hold the functions region. The output type is also converted to a
secret.&lt;/p>
&lt;p>Example input:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">func&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000">@main&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">%arg0&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>secret&lt;span style="color:#000;font-weight:bold">})&lt;/span> &lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">%0&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> arith&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#204a87;font-weight:bold">constant&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">100&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">%1&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> arith&lt;span style="color:#000;font-weight:bold">.&lt;/span>addi &lt;span style="color:#000">%0&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">%arg0&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">%1&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Output:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mlir" data-lang="mlir">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">func&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000">@main&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">%arg0&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>secret&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;)&lt;/span> &lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>secret&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">%0&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>generic ins&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">%arg0&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>secret&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f57900">^bb0&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">%arg1&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">):&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">%1&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> arith&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#204a87;font-weight:bold">constant&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">100&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">%2&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> arith&lt;span style="color:#000;font-weight:bold">.&lt;/span>addi &lt;span style="color:#000">%0&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">%arg1&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>yield &lt;span style="color:#000">%2&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span> &lt;span style="color:#000;font-weight:bold">-&amp;gt;&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>secret&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">%0&lt;/span> &lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">!&lt;/span>secret&lt;span style="color:#000;font-weight:bold">.&lt;/span>secret&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i32&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: SecretPasses</title><link>https://heir.dev/docs/passes/secretpasses/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/passes/secretpasses/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="-secret-capture-generic-ambient-scope">&lt;code>-secret-capture-generic-ambient-scope&lt;/code>&lt;/h3>
&lt;p>&lt;em>Capture the ambient scope used in a secret.generic&lt;/em>&lt;/p>
&lt;p>For each value used in the body of a &lt;code>secret.generic&lt;/code> op, which is defined
in the ambient scope outside the &lt;code>generic&lt;/code>, add it to the argument list of
the &lt;code>generic&lt;/code>.&lt;/p>
&lt;h3 id="-secret-distribute-generic">&lt;code>-secret-distribute-generic&lt;/code>&lt;/h3>
&lt;p>&lt;em>Distribute &lt;code>generic&lt;/code> ops through their bodies.&lt;/em>&lt;/p>
&lt;p>Converts &lt;code>generic&lt;/code> ops whose region contains many ops into smaller
sequences of generic ops whose regions contain a single op, dropping the
&lt;code>generic&lt;/code> part from any resulting &lt;code>generic&lt;/code> ops that have no
&lt;code>secret.secret&lt;/code> inputs. If the op has associated regions, and the operands
are not secret, then the generic is distributed recursively through the
op&amp;rsquo;s regions as well.&lt;/p>
&lt;p>This pass is intended to be used as part of a front-end pipeline, where a
program that operates on a secret type annotates the input to a region as
&lt;code>secret&lt;/code>, and then wraps the contents of the region in a single large
&lt;code>secret.generic&lt;/code>, then uses this pass to simplify it.&lt;/p>
&lt;p>The &lt;code>distribute-through&lt;/code> option allows one to specify a comma-separated
list of op names (e.g., &lt;code>distribute-thorugh=&amp;quot;affine.for,scf.if&amp;quot;&lt;/code>), which
limits the distribution to only pass through those ops. If unset, all ops
are distributed through when possible.&lt;/p>
&lt;h4 id="options">Options&lt;/h4>
&lt;pre tabindex="0">&lt;code>-distribute-through : comma-separated list of ops that should be distributed through
&lt;/code>&lt;/pre>&lt;h3 id="-secret-forget-secrets">&lt;code>-secret-forget-secrets&lt;/code>&lt;/h3>
&lt;p>&lt;em>Convert secret types to standard types&lt;/em>&lt;/p>
&lt;p>Drop the &lt;code>secret&amp;lt;...&amp;gt;&lt;/code> type from the IR, replacing it with the contained
type and the corresponding cleartext computation.&lt;/p>
&lt;h3 id="-secret-merge-adjacent-generics">&lt;code>-secret-merge-adjacent-generics&lt;/code>&lt;/h3>
&lt;p>&lt;em>Merge two adjacent generics into a single generic&lt;/em>&lt;/p>
&lt;p>This pass merges two immedaitely sequential generics into a single
generic. Useful as a sub-operation in some passes, and extracted into
its own pass for testing purposes.&lt;/p></description></item><item><title>Docs: YosysOptimizerPasses</title><link>https://heir.dev/docs/passes/yosysoptimizerpasses/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heir.dev/docs/passes/yosysoptimizerpasses/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="-yosys-optimizer">&lt;code>-yosys-optimizer&lt;/code>&lt;/h3>
&lt;p>&lt;em>Invoke Yosys to perform circuit optimization.&lt;/em>&lt;/p>
&lt;p>This pass invokes Yosys to convert an arithmetic circuit to an optimized
boolean circuit that uses the arith and comb dialects.&lt;/p>
&lt;p>Note that booleanization changes the function signature: multi-bit integers
are transformed to a tensor of booleans, for example, an &lt;code>i8&lt;/code> is converted
to &lt;code>tensor&amp;lt;8xi1&amp;gt;&lt;/code>.&lt;/p></description></item></channel></rss>