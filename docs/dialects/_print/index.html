<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.113.0"><link rel=canonical type=text/html href=https://heir.dev/docs/dialects/><link rel=alternate type=application/rss+xml href=https://heir.dev/docs/dialects/index.xml><meta name=robots content="noindex, nofollow"><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192><title>Dialects | HEIR</title><meta name=description content><meta property="og:title" content="Dialects"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://heir.dev/docs/dialects/"><meta itemprop=name content="Dialects"><meta itemprop=description content><meta name=twitter:card content="summary"><meta name=twitter:title content="Dialects"><meta name=twitter:description content><link rel=preload href=/scss/main.min.dffc1689fd83830a5fb090d38ca9680587c322008ad97c675ee0ca22e5fb10d5.css as=style><link href=/scss/main.min.dffc1689fd83830a5fb090d38ca9680587c322008ad97c675ee0ca22e5fb10d5.css rel=stylesheet integrity><script src=https://code.jquery.com/jquery-3.6.3.min.js integrity="sha512-STof4xm1wgkfm7heWqFJVn58Hm3EtS31XFaagaa8VMReCXAkQnJZ+jEy8PCC/iT18dFy95WcExNHFTqLyp72eQ==" crossorigin=anonymous></script>
<script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body class=td-section><header><nav class="td-navbar navbar-dark js-navbar-scroll"><div class="container-fluid flex-column flex-md-row"><a class=navbar-brand href=/><span class="navbar-brand__logo navbar-logo"><svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 500 500" style="enable-background:new 0 0 500 500"><g><path style="fill:#fff" d="M116.8525 421.9722c-5.7041.0-10.3442-4.3127-10.3442-9.6129V88.183c0-5.3002 4.6401-9.6117 10.3442-9.6117H320.858c3.0347.0 9.3959.5498 11.7506 2.6302l.3545.3442 58.905 63.2912c2.3101 2.491 2.9202 8.4928 2.9202 11.3184v256.2039c0 5.3002-4.6407 9.6129-10.3436 9.6129H116.8525z"/><g><g><g><path style="fill:#767676" d="M384.4445 423.2066H116.852c-6.3839.0-11.5786-4.8658-11.5786-10.8474V88.1831c0-5.9804 5.1947-10.8461 11.5786-10.8461h204.0062c.377.0 9.2786.0329 12.568 2.9389l.3947.3833 58.9508 63.337c3.2135 3.4652 3.2514 11.7924 3.2514 12.1593v256.2036C396.0231 418.3408 390.8284 423.2066 384.4445 423.2066zM116.5079 411.9189c.0848.0278.1999.0531.3441.0531h267.5925c.1442.0.2581-.0253.3441-.0531V156.1556c-.0076-.9033-.3593-3.7347-.7034-5.0037l-57.6527-61.9416c-1.4651-.3176-4.4533-.6389-5.5742-.6389H116.852c-.143.0-.2594.024-.3441.0531V411.9189zm267.4533-261.149zM327.0321 89.371v.0013V89.371z"/></g></g></g><g><g><path style="fill:#5b7fc0" d="M189.0874 210.1754l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.025 2.454-11.4897 6.4116-15.4473C177.5953 212.627 183.0601 210.1742 189.0874 210.1754zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403S197.0816 234.1722 197.0804 232.033z"/><path style="opacity:.3;fill:#fff" d="M189.0898 210.176c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 212.6276 183.0612 210.176 189.0898 210.176zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 236.239 197.0839 234.2399 197.0839 232.0372z"/><g><defs><path id="SVGID_1_" d="M194.7376 237.6875c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.999 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 234.2399 196.1861 236.239 194.7376 237.6875z"/></defs><clipPath id="SVGID_2_"><use xlink:href="#SVGID_1_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_2_);fill:#fff" d="M190.0704 225.0237c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 225.7247 191.9774 225.0237 190.0704 225.0237z"/><path style="opacity:.13;clip-path:url(#SVGID_2_);fill:#020202" d="M190.0704 225.0237c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 225.7247 191.9774 225.0237 190.0704 225.0237z"/></g><g><defs><path id="SVGID_3_" d="M189.0898 210.176c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 212.6276 183.0612 210.176 189.0898 210.176zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 236.239 197.0839 234.2399 197.0839 232.0372z"/></defs><clipPath id="SVGID_4_"><use xlink:href="#SVGID_3_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_4_);fill:#5b7fc0" d="M172.6595 215.6045c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8612 12.0547.0024 21.8636-9.797 21.8613-21.8612.0024-3.8475-1.0151-7.6326-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 209.1953 176.6171 211.647 172.6595 215.6045z"/></g></g><rect x="198.8952" y="225.1043" style="fill:#5b7fc0" width="122.6266" height="13.8671"/></g><g><path style="fill:#d95140" d="M189.0874 155.7611l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.0249 2.454-11.4897 6.4116-15.4473C177.5953 158.2128 183.0601 155.7599 189.0874 155.7611zm7.993 21.8577c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403C196.2508 181.7667 197.0816 179.758 197.0804 177.6188z"/><path style="opacity:.3;fill:#fff" d="M189.0898 155.7617c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 158.2134 183.0612 155.7617 189.0898 155.7617zm7.9941 21.8613c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 181.8248 197.0839 179.8256 197.0839 177.623z"/><g><defs><path id="SVGID_5_" d="M194.7376 183.2733c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.9989 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 179.8256 196.1861 181.8248 194.7376 183.2733z"/></defs><clipPath id="SVGID_6_"><use xlink:href="#SVGID_5_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_6_);fill:#fff" d="M190.0704 170.6095c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 171.3104 191.9774 170.6095 190.0704 170.6095z"/><path style="opacity:.13;clip-path:url(#SVGID_6_);fill:#020202" d="M190.0704 170.6095c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 171.3104 191.9774 170.6095 190.0704 170.6095z"/></g><g><defs><path id="SVGID_7_" d="M189.0898 155.7617c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 158.2134 183.0612 155.7617 189.0898 155.7617zm7.9941 21.8613c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 181.8248 197.0839 179.8256 197.0839 177.623z"/></defs><clipPath id="SVGID_8_"><use xlink:href="#SVGID_7_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_8_);fill:#d95140" d="M172.6595 161.1903c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8613 12.0547.0024 21.8636-9.797 21.8613-21.8613.0024-3.8474-1.0151-7.6326-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 154.7811 176.6171 157.2327 172.6595 161.1903z"/></g><rect x="198.8952" y="170.69" style="fill:#d95140" width="122.6266" height="13.8671"/></g><g><g><path style="fill:#56a55c" d="M189.5379 264.6147l.0012-.0012c7.7751.0012 15.0294 4.1862 18.932 10.9235 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032-5.8394.0-11.3281-2.2733-15.458-6.4032-4.13-4.13-6.4032-9.6186-6.4056-15.4628.0012-6.0249 2.454-11.4897 6.4116-15.4472C178.0458 267.0663 183.5105 264.6135 189.5379 264.6147zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6538 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403C196.7013 290.6202 197.5321 288.6115 197.5309 286.4723z"/><path style="opacity:.3;fill:#fff" d="M189.5403 264.6153c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8065-21.8612-21.8613.0-6.0285 2.4516-11.492 6.4116-15.452C178.0482 267.0669 183.5117 264.6153 189.5403 264.6153zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.6366 290.6783 197.5344 288.6792 197.5344 286.4765z"/><g><defs><path id="SVGID_9_" d="M195.1881 292.1268c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.9989 7.9942-7.9941 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.5344 288.6792 196.6366 290.6783 195.1881 292.1268z"/></defs><clipPath id="SVGID_10_"><use xlink:href="#SVGID_9_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_10_);fill:#fff" d="M190.5209 279.463c-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7446-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9941 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C194.239 280.164 192.4279 279.463 190.5209 279.463z"/><path style="opacity:.13;clip-path:url(#SVGID_10_);fill:#020202" d="M190.5209 279.463c-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7446-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9941 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C194.239 280.164 192.4279 279.463 190.5209 279.463z"/></g><g><defs><path id="SVGID_11_" d="M189.5403 264.6153c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8065-21.8612-21.8613.0-6.0285 2.4516-11.492 6.4116-15.452C178.0482 267.0669 183.5117 264.6153 189.5403 264.6153zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.6366 290.6783 197.5344 288.6792 197.5344 286.4765z"/></defs><clipPath id="SVGID_12_"><use xlink:href="#SVGID_11_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_12_);fill:#56a55c" d="M173.11 270.0439c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8613 12.0547.0024 21.8636-9.797 21.8613-21.8613.0024-3.8474-1.0151-7.6326-2.9353-10.9462-3.8977-6.7325-11.1497-10.9151-18.926-10.9151C182.5311 263.6346 177.0676 266.0863 173.11 270.0439z"/></g></g><rect x="199.3456" y="279.5436" style="fill:#56a55c" width="122.6266" height="13.8671"/></g><g><g><path style="fill:#f1bc42" d="M189.0874 318.7208l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3305-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.025 2.454-11.4897 6.4116-15.4472C177.5953 321.1724 183.0601 318.7196 189.0874 318.7208zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403S197.0816 342.7176 197.0804 340.5784z"/><path style="opacity:.3;fill:#fff" d="M189.0898 318.7214c7.7763.0 15.0283 4.1826 18.926 10.915 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8612-12.0547.0024-21.8636-9.8065-21.8612-21.8612.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 321.173 183.0612 318.7214 189.0898 318.7214zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 344.7844 197.0839 342.7853 197.0839 340.5826z"/><g><defs><path id="SVGID_13_" d="M194.7376 346.2329c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.999 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 342.7853 196.1861 344.7844 194.7376 346.2329z"/></defs><clipPath id="SVGID_14_"><use xlink:href="#SVGID_13_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_14_);fill:#fff" d="M190.0704 333.5691c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0834 6.1218 2.8788C193.7885 334.2701 191.9774 333.5691 190.0704 333.5691z"/><path style="opacity:.13;clip-path:url(#SVGID_14_);fill:#020202" d="M190.0704 333.5691c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0834 6.1218 2.8788C193.7885 334.2701 191.9774 333.5691 190.0704 333.5691z"/></g><g><defs><path id="SVGID_15_" d="M189.0898 318.7214c7.7763.0 15.0283 4.1826 18.926 10.915 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8612-12.0547.0024-21.8636-9.8065-21.8612-21.8612.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 321.173 183.0612 318.7214 189.0898 318.7214zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 344.7844 197.0839 342.7853 197.0839 340.5826z"/></defs><clipPath id="SVGID_16_"><use xlink:href="#SVGID_15_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_16_);fill:#f1bc42" d="M172.6595 324.15c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8612 12.0547.0024 21.8636-9.797 21.8613-21.8612.0024-3.8474-1.0151-7.6327-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 317.7407 176.6171 320.1924 172.6595 324.15z"/></g></g><rect x="198.8952" y="333.6497" style="fill:#f1bc42" width="122.6266" height="13.8671"/></g></g></svg></span><span class=navbar-brand__name>HEIR</span></a><div class="td-navbar-nav-scroll ms-md-auto" id=main_navbar><ul class=navbar-nav><li class=nav-item><a class="nav-link active" href=/><span>Home</span></a></li><li class=nav-item><a class="nav-link active" href=/docs/><span>Docs</span></a></li><li class=nav-item><a class=nav-link href=/blog/><span>Blog</span></a></li><li class=nav-item><a class=nav-link href=/community/><span>Community</span></a></li><li class=nav-item><a class=nav-link href=https://github.com/google/heir/ target=_blank rel=noopener><span>GitHub</span></a></li></ul></div><div class="d-none d-lg-block"></div></div></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 ps-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This is the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/docs/dialects/>Return to the regular view of this page</a>.</p></div><h1 class=title>Dialects</h1><ul><li>1: <a href=#pg-7a2d769a54237b8d0845fe32a6451c2b>BGV</a></li><li>2: <a href=#pg-5f74537b9610a2b3f8ddf498be3d47b0>CGGI</a></li><li>3: <a href=#pg-80cc312dd83f43a069330083f04eb4f2>Comb</a></li><li>4: <a href=#pg-c5dda3cb8e694541eacbee638af7317d>LWE</a></li><li>5: <a href=#pg-cabcacfc9b7cbac2ba4f6fc790a84b68>PolyExt</a></li><li>6: <a href=#pg-b18fea903e4651113f5317788f1491e1>Polynomial</a></li><li>7: <a href=#pg-f7ffac8ba93b73b8a62e185ec8643d63>Secret</a></li><li>8: <a href=#pg-678c1db0f9b2ed4c9d43b790f890bea0>TfheRust</a></li></ul><div class=content><p>This section contains the reference documentation for all of the dialects
defined in HEIR.</p></div></div><div class=td-content><h1 id=pg-7a2d769a54237b8d0845fe32a6451c2b>1 - BGV</h1><p>The BGV dialect defines the types and operations of the BGV cryptosystem.</p><h2 id=bgv-attributes>BGV attributes</h2><h3 id=bgvringsattr>BGVRingsAttr</h3><p>Syntax:</p><pre tabindex=0><code>#bgv.rings&lt;
  ::llvm::ArrayRef&lt;::mlir::heir::polynomial::RingAttr&gt;   # rings
&gt;
</code></pre><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>rings</td><td style=text-align:center><code>::llvm::ArrayRef&lt;::mlir::heir::polynomial::RingAttr></code></td><td></td></tr></tbody></table><h2 id=bgv-types>BGV types</h2><h3 id=ciphertexttype>CiphertextType</h3><p>A type for BGV Ciphertext</p><p>Syntax:</p><pre tabindex=0><code>!bgv.ciphertext&lt;
  ::mlir::heir::bgv::BGVRingsAttr,   # rings
  unsigned,   # dim
  std::optional&lt;uint64_t&gt;   # level
&gt;
</code></pre><p>A type for BGV Ciphertexts.</p><p>This type tracks the BGV ciphertext parameters, including the ciphertext
dimension (number of polynomials) and the set of rings that were used for
the particular BGV scheme instance. The default dimension is 2, representing
a ciphertext that is canonically encrypted against the key basis <code>(1, s)</code>.</p><p>The type also includes a ring parameter specification.</p><p>For example, <code>bgv.ciphertext&lt;rings=#rings, dim=3></code> is a ciphertext with 3
polynomials (c_0, c_1, c_2).</p><p>The optional attribute <code>level</code> specifies the &ldquo;current ring&rdquo;.</p><h4 id=parameters-1>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>rings</td><td style=text-align:center><code>::mlir::heir::bgv::BGVRingsAttr</code></td><td></td></tr><tr><td style=text-align:center>dim</td><td style=text-align:center><code>unsigned</code></td><td></td></tr><tr><td style=text-align:center>level</td><td style=text-align:center><code>std::optional&lt;uint64_t></code></td><td></td></tr></tbody></table><h2 id=bgv-ops>BGV ops</h2><h3 id=bgvadd-heirbgvaddop><code>bgv.add</code> (heir::bgv::AddOp)</h3><p><em>Addition operation between ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `bgv.add` `(` operands `)` attr-dict `:` type($output)
</code></pre><p>Traits: Commutative, SameOperandsAndResultType</p><p>Interfaces: InferTypeOpInterface</p><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>x</code></td><td>A type for BGV Ciphertext</td></tr><tr><td style=text-align:center><code>y</code></td><td>A type for BGV Ciphertext</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for BGV Ciphertext</td></tr></tbody></table><h3 id=bgvmodulus_switch-heirbgvmodulusswitch><code>bgv.modulus_switch</code> (heir::bgv::ModulusSwitch)</h3><p><em>Lower the modulus level of the ciphertext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `bgv.modulus_switch` `(` operands `)` attr-dict `:`  `(` type(operands) `)` `-&gt;` type(results)
</code></pre><p>Traits: SameOperandsAndResultRings</p><h4 id=attributes>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>from_level</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr><tr><td><code>to_level</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></table><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>x</code></td><td>A type for BGV Ciphertext</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for BGV Ciphertext</td></tr></tbody></table><h3 id=bgvmul-heirbgvmulop><code>bgv.mul</code> (heir::bgv::MulOp)</h3><p><em>Multiplication operation between ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `bgv.mul` `(` operands `)` attr-dict `:` type($x) `-&gt;` type($output)
</code></pre><p>Traits: Commutative, SameOperandsAndResultRings, SameTypeOperands</p><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>x</code></td><td>A type for BGV Ciphertext</td></tr><tr><td style=text-align:center><code>y</code></td><td>A type for BGV Ciphertext</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for BGV Ciphertext</td></tr></tbody></table><h3 id=bgvnegate-heirbgvnegate><code>bgv.negate</code> (heir::bgv::Negate)</h3><p><em>Negate the coefficients of the ciphertext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `bgv.negate` `(` operands `)` attr-dict `:` type($output)
</code></pre><p>Traits: SameOperandsAndResultType</p><p>Interfaces: InferTypeOpInterface</p><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>x</code></td><td>A type for BGV Ciphertext</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for BGV Ciphertext</td></tr></tbody></table><h3 id=bgvrelinearize-heirbgvrelinearize><code>bgv.relinearize</code> (heir::bgv::Relinearize)</h3><p><em>Relinearize the ciphertext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `bgv.relinearize` `(` operands `)` attr-dict `:`  `(` type(operands) `)` `-&gt;` type(results)
</code></pre><p>This op takes integer array attributes <code>from_basis</code> and <code>to_basis</code> that are
used to indicate the key basis from which and to which the ciphertext is
encrypted against. A ciphertext is canonically encrypted against key basis
<code>(1, s)</code>. After a multiplication, its size will increase and the basis will be
<code>(1, s, s^2)</code>. The array that represents the key basis is constructed by
listing the powers of <code>s</code> at each position of the array. For example, <code>(1, s, s^2)</code> corresponds to <code>[0, 1, 2]</code>, while <code>(1, s^2)</code> corresponds to <code>[0, 2]</code>.</p><p>Traits: SameOperandsAndResultRings</p><h4 id=attributes-1>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>from_basis</code></td><td>::mlir::DenseI32ArrayAttr</td><td>i32 dense array attribute</td></tr><tr><td><code>to_basis</code></td><td>::mlir::DenseI32ArrayAttr</td><td>i32 dense array attribute</td></tr></table><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>x</code></td><td>A type for BGV Ciphertext</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for BGV Ciphertext</td></tr></tbody></table><h3 id=bgvrotate-heirbgvrotate><code>bgv.rotate</code> (heir::bgv::Rotate)</h3><p><em>Rotate the coefficients of the ciphertext using a Galois automorphism.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `bgv.rotate` `(` operands `)` attr-dict `:`  `(` type(operands) `)` `-&gt;` type(results)
</code></pre><p>Traits: SameOperandsAndResultRings</p><h4 id=attributes-2>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>offset</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></table><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>x</code></td><td>A type for BGV Ciphertext</td></tr></tbody></table><h4 id=results-5>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for BGV Ciphertext</td></tr></tbody></table><h3 id=bgvsub-heirbgvsubop><code>bgv.sub</code> (heir::bgv::SubOp)</h3><p><em>Subtraction operation between ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `bgv.sub` `(` operands `)` attr-dict `:` type($output)
</code></pre><p>Traits: SameOperandsAndResultType</p><p>Interfaces: InferTypeOpInterface</p><h4 id=operands-6>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>x</code></td><td>A type for BGV Ciphertext</td></tr><tr><td style=text-align:center><code>y</code></td><td>A type for BGV Ciphertext</td></tr></tbody></table><h4 id=results-6>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for BGV Ciphertext</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-5f74537b9610a2b3f8ddf498be3d47b0>2 - CGGI</h1><p>A dialect for types and operations in the CGGI cryptosystem</p><h2 id=cggi-ops>CGGI ops</h2><h3 id=cggiand-heircggiandop><code>cggi.and</code> (heir::cggi::AndOp)</h3><p><em>Logical AND of two ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.and` operands attr-dict `-&gt;` type($output)
</code></pre><p>Traits: AlwaysSpeculatableImplTrait, Commutative, SameOperandsAndResultType</p><p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>A type for LWE ciphertexts</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>A type for LWE ciphertexts</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for LWE ciphertexts</td></tr></tbody></table><h3 id=cggilut2-heircggilut2op><code>cggi.lut2</code> (heir::cggi::Lut2Op)</h3><p><em>A lookup table on two inputs.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.lut2` `(` operands `)` attr-dict `:` type($output)
</code></pre><p>An op representing a lookup table applied to some number <code>n</code> of ciphertexts
encrypting boolean input bits.</p><p>Over cleartext bits <code>a, b, c</code>, using <code>n = 3</code> for example, the operation
computed by this function can be interpreted as</p><pre tabindex=0><code>  truth_table &gt;&gt; {c, b, a}
</code></pre><p>where <code>{c, b, a}</code> is the unsigned 3-bit integer with bits <code>c, b, a</code> from most
significant bit to least-significant bit. The input are combined into a
single ciphertext input to the lookup table using products with plaintexts
and sums.</p><p>Traits: AlwaysSpeculatableImplTrait, Commutative, SameOperandsAndResultType</p><p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>lookup_table</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr></table><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>b</code></td><td>A type for LWE ciphertexts</td></tr><tr><td style=text-align:center><code>a</code></td><td>A type for LWE ciphertexts</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for LWE ciphertexts</td></tr></tbody></table><h3 id=cggilut3-heircggilut3op><code>cggi.lut3</code> (heir::cggi::Lut3Op)</h3><p><em>A lookup table on three inputs.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.lut3` `(` operands `)` attr-dict `:` type($output)
</code></pre><p>An op representing a lookup table applied to some number <code>n</code> of ciphertexts
encrypting boolean input bits.</p><p>Over cleartext bits <code>a, b, c</code>, using <code>n = 3</code> for example, the operation
computed by this function can be interpreted as</p><pre tabindex=0><code>  truth_table &gt;&gt; {c, b, a}
</code></pre><p>where <code>{c, b, a}</code> is the unsigned 3-bit integer with bits <code>c, b, a</code> from most
significant bit to least-significant bit. The input are combined into a
single ciphertext input to the lookup table using products with plaintexts
and sums.</p><p>Traits: AlwaysSpeculatableImplTrait, Commutative, SameOperandsAndResultType</p><p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-1>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>lookup_table</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr></table><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>c</code></td><td>A type for LWE ciphertexts</td></tr><tr><td style=text-align:center><code>b</code></td><td>A type for LWE ciphertexts</td></tr><tr><td style=text-align:center><code>a</code></td><td>A type for LWE ciphertexts</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for LWE ciphertexts</td></tr></tbody></table><h3 id=cggior-heircggiorop><code>cggi.or</code> (heir::cggi::OrOp)</h3><p><em>Logical OR of two ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.or` operands attr-dict `-&gt;` type($output)
</code></pre><p>Traits: AlwaysSpeculatableImplTrait, Commutative, SameOperandsAndResultType</p><p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>A type for LWE ciphertexts</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>A type for LWE ciphertexts</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for LWE ciphertexts</td></tr></tbody></table><h3 id=cggixor-heircggixorop><code>cggi.xor</code> (heir::cggi::XorOp)</h3><p><em>Logical XOR of two ciphertexts.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `cggi.xor` operands attr-dict `-&gt;` type($output)
</code></pre><p>Traits: AlwaysSpeculatableImplTrait, Commutative, SameOperandsAndResultType</p><p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>A type for LWE ciphertexts</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>A type for LWE ciphertexts</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for LWE ciphertexts</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-80cc312dd83f43a069330083f04eb4f2>3 - Comb</h1><p>Types and operations for comb dialect
This dialect defines the <code>comb</code> dialect, which is intended to be a generic
representation of combinational logic outside of a particular use-case.</p><h2 id=operation-definition>Operation definition</h2><h3 id=combadd-heircombaddop><code>comb.add</code> (heir::comb::AddOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.add` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: AlwaysSpeculatableImplTrait, Commutative, SameOperandsAndResultType, SameTypeOperands</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=comband-heircombandop><code>comb.and</code> (heir::comb::AndOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.and` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: AlwaysSpeculatableImplTrait, Commutative, SameOperandsAndResultType, SameTypeOperands</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-1>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combconcat-heircombconcatop><code>comb.concat</code> (heir::comb::ConcatOp)</h3><p><em>Concatenate a variadic list of operands together.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.concat` $inputs attr-dict `:` qualified(type($inputs))
</code></pre><p>See the comb rationale document for details on operand ordering.</p><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combextract-heircombextractop><code>comb.extract</code> (heir::comb::ExtractOp)</h3><p><em>Extract a range of bits into a smaller value, lowBit specifies the lowest bit included.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.extract` $input `from` $lowBit attr-dict `:` functional-type($input, $result)
</code></pre><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-2>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>lowBit</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combicmp-heircombicmpop><code>comb.icmp</code> (heir::comb::ICmpOp)</h3><p><em>Compare two integer values</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.icmp` (`bin` $twoState^)? $predicate $lhs `,` $rhs attr-dict `:` qualified(type($lhs))
</code></pre><p>This operation compares two integers using a predicate. If the predicate is
true, returns 1, otherwise returns 0. This operation always returns a one
bit wide result.</p><pre tabindex=0><code>    %r = comb.icmp eq %a, %b : i4
</code></pre><p>Traits: AlwaysSpeculatableImplTrait, SameTypeOperands</p><p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-3>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>predicate</code></td><td>::mlir::heir::comb::ICmpPredicateAttr</td><td>hw.icmp comparison predicate</td></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=combmul-heircombmulop><code>comb.mul</code> (heir::comb::MulOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.mul` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: AlwaysSpeculatableImplTrait, Commutative, SameOperandsAndResultType, SameTypeOperands</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-4>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-5>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combmux-heircombmuxop><code>comb.mux</code> (heir::comb::MuxOp)</h3><p><em>Return one or the other operand depending on a selector bit</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.mux` (`bin` $twoState^)? $cond `,` $trueValue `,` $falseValue  attr-dict `:` qualified(type($result))
</code></pre><pre tabindex=0><code>  %0 = mux %pred, %tvalue, %fvalue : i4
</code></pre><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-5>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-6>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cond</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>trueValue</code></td><td>any type</td></tr><tr><td style=text-align:center><code>falseValue</code></td><td>any type</td></tr></tbody></table><h4 id=results-6>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=combor-heircomborop><code>comb.or</code> (heir::comb::OrOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.or` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: AlwaysSpeculatableImplTrait, Commutative, SameOperandsAndResultType, SameTypeOperands</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-6>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-7>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-7>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combparity-heircombparityop><code>comb.parity</code> (heir::comb::ParityOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.parity` (`bin` $twoState^)? $input attr-dict `:` qualified(type($input))
</code></pre><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-7>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-8>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-8>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=combreplicate-heircombreplicateop><code>comb.replicate</code> (heir::comb::ReplicateOp)</h3><p><em>Concatenate the operand a constant number of times</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.replicate` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-9>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-9>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combtruth_table-heircombtruthtableop><code>comb.truth_table</code> (heir::comb::TruthTableOp)</h3><p><em>Return a true/false based on a lookup table</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.truth_table` $inputs `-&gt;` $lookupTable attr-dict
</code></pre><pre tabindex=0><code>  %a = ... : i1
  %b = ... : i1
  %0 = comb.truth_table %a, %b -&gt; 6 : ui4
</code></pre><p>This operation assumes that the lookup table is described as an integer of
2^n bits to fully specify the table. Inputs are sorted MSB -> LSB from left
to right and the offset into <code>lookupTable</code> is computed from them. The
integer containing the truth table value&rsquo;s LSB is the output for the input
&ldquo;all false&rdquo;, and the MSB is the output for the input &ldquo;all true&rdquo;.</p><p>No difference from array_get into an array of constants except for xprop
behavior. If one of the inputs is unknown, but said input doesn&rsquo;t make a
difference in the output (based on the lookup table) the result should not
be &lsquo;x&rsquo; &ndash; it should be the well-known result.</p><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-8>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>lookupTable</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr></table><h4 id=operands-10>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of 1-bit signless integer</td></tr></tbody></table><h4 id=results-10>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=combxor-heircombxorop><code>comb.xor</code> (heir::comb::XorOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.xor` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: AlwaysSpeculatableImplTrait, Commutative, SameOperandsAndResultType, SameTypeOperands</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-9>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-11>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-11>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h2 id=comb-types>Comb types</h2><h2 id=comb-ops>Comb ops</h2><h3 id=combadd-heircombaddop-1><code>comb.add</code> (heir::comb::AddOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.add` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: AlwaysSpeculatableImplTrait, Commutative, SameOperandsAndResultType, SameTypeOperands</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-10>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-12>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-12>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=comband-heircombandop-1><code>comb.and</code> (heir::comb::AndOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.and` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: AlwaysSpeculatableImplTrait, Commutative, SameOperandsAndResultType, SameTypeOperands</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-11>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-13>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-13>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combconcat-heircombconcatop-1><code>comb.concat</code> (heir::comb::ConcatOp)</h3><p><em>Concatenate a variadic list of operands together.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.concat` $inputs attr-dict `:` qualified(type($inputs))
</code></pre><p>See the comb rationale document for details on operand ordering.</p><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-14>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-14>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combextract-heircombextractop-1><code>comb.extract</code> (heir::comb::ExtractOp)</h3><p><em>Extract a range of bits into a smaller value, lowBit specifies the lowest bit included.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.extract` $input `from` $lowBit attr-dict `:` functional-type($input, $result)
</code></pre><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-12>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>lowBit</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-15>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-15>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combicmp-heircombicmpop-1><code>comb.icmp</code> (heir::comb::ICmpOp)</h3><p><em>Compare two integer values</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.icmp` (`bin` $twoState^)? $predicate $lhs `,` $rhs attr-dict `:` qualified(type($lhs))
</code></pre><p>This operation compares two integers using a predicate. If the predicate is
true, returns 1, otherwise returns 0. This operation always returns a one
bit wide result.</p><pre tabindex=0><code>    %r = comb.icmp eq %a, %b : i4
</code></pre><p>Traits: AlwaysSpeculatableImplTrait, SameTypeOperands</p><p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-13>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>predicate</code></td><td>::mlir::heir::comb::ICmpPredicateAttr</td><td>hw.icmp comparison predicate</td></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-16>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-16>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=combmul-heircombmulop-1><code>comb.mul</code> (heir::comb::MulOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.mul` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: AlwaysSpeculatableImplTrait, Commutative, SameOperandsAndResultType, SameTypeOperands</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-14>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-17>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-17>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combmux-heircombmuxop-1><code>comb.mux</code> (heir::comb::MuxOp)</h3><p><em>Return one or the other operand depending on a selector bit</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.mux` (`bin` $twoState^)? $cond `,` $trueValue `,` $falseValue  attr-dict `:` qualified(type($result))
</code></pre><pre tabindex=0><code>  %0 = mux %pred, %tvalue, %fvalue : i4
</code></pre><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-15>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-18>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cond</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>trueValue</code></td><td>any type</td></tr><tr><td style=text-align:center><code>falseValue</code></td><td>any type</td></tr></tbody></table><h4 id=results-18>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=combor-heircomborop-1><code>comb.or</code> (heir::comb::OrOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.or` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: AlwaysSpeculatableImplTrait, Commutative, SameOperandsAndResultType, SameTypeOperands</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-16>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-19>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-19>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combparity-heircombparityop-1><code>comb.parity</code> (heir::comb::ParityOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.parity` (`bin` $twoState^)? $input attr-dict `:` qualified(type($input))
</code></pre><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-17>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-20>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-20>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=combreplicate-heircombreplicateop-1><code>comb.replicate</code> (heir::comb::ReplicateOp)</h3><p><em>Concatenate the operand a constant number of times</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.replicate` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-21>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-21>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=combtruth_table-heircombtruthtableop-1><code>comb.truth_table</code> (heir::comb::TruthTableOp)</h3><p><em>Return a true/false based on a lookup table</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.truth_table` $inputs `-&gt;` $lookupTable attr-dict
</code></pre><pre tabindex=0><code>  %a = ... : i1
  %b = ... : i1
  %0 = comb.truth_table %a, %b -&gt; 6 : ui4
</code></pre><p>This operation assumes that the lookup table is described as an integer of
2^n bits to fully specify the table. Inputs are sorted MSB -> LSB from left
to right and the offset into <code>lookupTable</code> is computed from them. The
integer containing the truth table value&rsquo;s LSB is the output for the input
&ldquo;all false&rdquo;, and the MSB is the output for the input &ldquo;all true&rdquo;.</p><p>No difference from array_get into an array of constants except for xprop
behavior. If one of the inputs is unknown, but said input doesn&rsquo;t make a
difference in the output (based on the lookup table) the result should not
be &lsquo;x&rsquo; &ndash; it should be the well-known result.</p><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-18>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>lookupTable</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr></table><h4 id=operands-22>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of 1-bit signless integer</td></tr></tbody></table><h4 id=results-22>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=combxor-heircombxorop-1><code>comb.xor</code> (heir::comb::XorOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `comb.xor` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
</code></pre><p>Traits: AlwaysSpeculatableImplTrait, Commutative, SameOperandsAndResultType, SameTypeOperands</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-19>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>twoState</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-23>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-23>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-c5dda3cb8e694541eacbee638af7317d>4 - LWE</h1><h2 id=lwe-attributes>LWE attributes</h2><h3 id=bitfieldencodingattr>BitFieldEncodingAttr</h3><p>An attribute describing encoded LWE plaintexts using bit fields.</p><p>Syntax:</p><pre tabindex=0><code>#lwe.bit_field_encoding&lt;
  unsigned,   # cleartext_start
  unsigned   # cleartext_bitwidth
&gt;
</code></pre><p>A bit field encoding of an integer describes which contiguous region
of bits a small integer occupies within a larger integer.</p><p>In LWE the plaintexts are integers of a given bit width, and the cleartext
messages are integers of a smaller bit width. A common example might be
3-bit cleartexts inside a 32-bit plaintext. In the CGGI FHE scheme, the
3-bit cleartext might be stored as follows, where 0 denotes a 0 bit, <code>b</code>
denotes a bit of the cleartext, <code>n</code> denotes a bit reserved for noise, and
<code>|</code> is a visual aid to show where the bit fields begin and end.</p><pre tabindex=0><code>   0|bbb|nn...n
MSB^          ^LSB
</code></pre><p>The data describing the encoding consists of the starting bit positions of
the cleartext bit field and its width, where the LSB is bit 0 and the MSB
is bit <code>bit_width-1</code>. So the above example would have starting bit <code>30</code> and
width <code>3</code>. The bits preceding (more significant than) the starting bit are
reserved for padding, and the bits following (less significant than) the
ending bit are reserved for noise.</p><p>The presence of this attribute as the <code>encoding</code> attribute of a tensor
indicates that the tensor is an LWE ciphertext.</p><p>Example:</p><pre tabindex=0><code>#lwe_encoding = #lwe.bit_field_encoding&lt;cleartext_start=30, cleartext_bitwidth=3&gt;
%lwe_ciphertext = arith.constant &lt;[1,2,3,4]&gt; : tensor&lt;4xi32, #lwe_encoding&gt;
</code></pre><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>cleartext_start</td><td style=text-align:center><code>unsigned</code></td><td></td></tr><tr><td style=text-align:center>cleartext_bitwidth</td><td style=text-align:center><code>unsigned</code></td><td></td></tr></tbody></table><h3 id=lweparamsattr>LWEParamsAttr</h3><p>Syntax:</p><pre tabindex=0><code>#lwe.lwe_params&lt;
  IntegerAttr,   # cmod
  unsigned   # dimension
&gt;
</code></pre><h4 id=parameters-1>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>cmod</td><td style=text-align:center><code>IntegerAttr</code></td><td></td></tr><tr><td style=text-align:center>dimension</td><td style=text-align:center><code>unsigned</code></td><td></td></tr></tbody></table><h3 id=unspecifiedbitfieldencodingattr>UnspecifiedBitFieldEncodingAttr</h3><p>An attribute describing unspecified bit field encodings.</p><p>Syntax:</p><pre tabindex=0><code>#lwe.unspecified_bit_field_encoding&lt;
  unsigned   # cleartext_bitwidth
&gt;
</code></pre><p>See LWE_BitFieldEncoding for a description of bit field encodings.</p><p>This attribute describes an unspecified bit field encoding; this is where
the starting bit position of the cleartext bit field is unspecified, but its
width is fixed. A noise growth analysis should be performed to determine the
optimal amount of bits needed for noise and padding to specify the bit field
encodings starting bit position.</p><p>Example:</p><pre tabindex=0><code>#lwe_encoding = #lwe.unspecified_bit_field_encoding&lt;cleartext_bitwidth=3&gt;
%lwe_ciphertext = arith.constant &lt;[1,2,3,4]&gt; : tensor&lt;4xi32, #lwe_encoding&gt;
</code></pre><h4 id=parameters-2>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>cleartext_bitwidth</td><td style=text-align:center><code>unsigned</code></td><td></td></tr></tbody></table><h3 id=inversecanonicalembeddingencodingattr>InverseCanonicalEmbeddingEncodingAttr</h3><p>An attribute describing encoded RLWE plaintexts via the rounded inverse canonical embedding.</p><p>Syntax:</p><pre tabindex=0><code>#lwe.inverse_canonical_embedding_encoding&lt;
  unsigned,   # cleartext_start
  unsigned   # cleartext_bitwidth
&gt;
</code></pre><p>Let $n$ be the degree of the polynomials in the plaintext space. An
&ldquo;inverse canonical embedding encoding&rdquo; of a list of real or complex values
$v_1, \dots, v_{n/2}$ is (almost) the inverse of the following decoding
map.</p><p>Define a map $\tau_N$ that maps a polynomial $p \in \mathbb{Z}[x] / (x^N + 1)
\to \mathbb{C}^{N/2}$ by evaluating it at the following $N/2$ points,
where $\omega = e^{2 \pi i / 2N}$ is the primitive $2N$th root of unity:</p><p>[
\omega, \omega^3, \omega^5, \dots, \omega^{N-1}
]</p><p>Then the complete decoding operation is $\textup{Decode}(p) =
(1/\Delta)\tau_N(p)$, where $\Delta$ is a scaling parameter and $\tau_N$ is
the truncated canonical embedding above. The encoding operation is the
inverse of the decoding operation, with some caveats explained below.</p><p>The map $\tau_N$ is derived from the so-called <em>canonical embedding</em>
$\tau$, though in the standard canonical embedding, we evaluate at all odd
powers of the root of unity, $\omega, \omega^3, \dots, \omega^{2N-1}$. For
polynomials in the slightly larger space $\mathbb{R}[x] / (x^N + 1)$, the
image of the canonical embedding is the subspace $H \subset \mathbb{C}^N$
defined by tuples $(z_1, \dots, z_N)$ such that $\overline{z_i} =
\overline{z_{N-i+1}}$. Note that this property holds because polynomial
evaluation commutes with complex conjugates, and the second half of the
roots of unity evaluate are complex conjugates of the first half. The
converse, that any such tuple with complex conjugate symmetry has an
inverse under $\tau$ with all real coefficients, makes $\tau$ is a
bijection onto $H$. $\tau$ and its inverse are explicitly computable as
discrete Fourier Transforms.</p><p>Because of the symmetry in canonical embedding for real polynomials, inputs
to this encoding can be represented as a list of $N/2$ complex points, with
the extra symmetric structure left implicit. $\tau_N$ and its inverse can
also be explicitly computed without need to expand the vectors to length
$N$.</p><p>The rounding step is required to invert the decoding because, while
cleartexts must be (implicitly) in the subspace $H$, they need not be the
output of $\tau_N$ for an <em>integer</em> polynomial. The rounding step ensures
we can use integer polynomial plaintexts for the FHE operations. There are
multiple rounding mechanisms, and this attribute does not specify which is
used, because in theory two ciphertexts that have used different roundings
are still compatible, though they may have different noise growth patterns.</p><p>The scaling parameter $\Delta$ is specified by the <code>cleartext_start</code> and
<code>cleartext_bitwidth</code> parameters, which are applied coefficient-wise using
the same semantics as the <code>bit_field_encoding</code>.</p><p>This attribute can be used in multiple ways:</p><ul><li>On a <code>poly.poly</code>, it asserts that the polynomial has been transformed
from a coefficient list using the canonical embedding.</li><li>On a tensor of <code>poly.poly</code>, it asserts that the tensor is an RLWE
ciphertext for some RLWE scheme that supports the approximate embedding
encoding.</li></ul><p>A typical flow for the CKKS scheme using this encoding would be to apply an
inverse FFT operation to invert the canonical embedding to be a polynomial
with real coefficients, then encrypt scale the resulting polynomial&rsquo;s
coefficients according to the scaling parameters, then round to get integer
coefficients.</p><p>Example:</p><pre tabindex=0><code>#generator = #poly.polynomial&lt;1 + x**1024&gt;
#ring = #poly.ring&lt;cmod=65536, ideal=#generator&gt;
#lwe_encoding = #lwe.polynomial_evaluation_encoding&lt;cleartext_start=30, cleartext_bitwidth=3&gt;

%evals = arith.constant &lt;[1, 2, 4, 5]&gt; : tensor&lt;4xi16&gt;
// TODO(https://github.com/google/heir/issues/182): fix docs
// Note no `intt` operation exists in poly yet.
%poly1 = poly.intt %evals : tensor&lt;4xi16&gt; -&gt; !poly.poly&lt;#ring, #eval_encoding&gt;
%poly2 = poly.intt %evals : tensor&lt;4xi16&gt; -&gt; !poly.poly&lt;#ring, #eval_encoding&gt;
%rlwe_ciphertext = tensor.from_elements %poly1, %poly2 : tensor&lt;2x!poly.poly&lt;#ring, #eval_encoding&gt;&gt;
</code></pre><h4 id=parameters-3>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>cleartext_start</td><td style=text-align:center><code>unsigned</code></td><td></td></tr><tr><td style=text-align:center>cleartext_bitwidth</td><td style=text-align:center><code>unsigned</code></td><td></td></tr></tbody></table><h3 id=polynomialcoefficientencodingattr>PolynomialCoefficientEncodingAttr</h3><p>An attribute describing encoded RLWE plaintexts via coefficients.</p><p>Syntax:</p><pre tabindex=0><code>#lwe.polynomial_coefficient_encoding&lt;
  unsigned,   # cleartext_start
  unsigned   # cleartext_bitwidth
&gt;
</code></pre><p>A coefficient encoding of a list of integers asserts that the coefficients
of the polynomials contain the cleartexts, with the same semantics as
<code>bit_field_encoding</code> for per-coefficient encodings.</p><p>The presence of this attribute as the <code>encoding</code> attribute of a tensor of
<code>poly.poly</code> indicates that the tensor is an RLWE ciphertext for some RLWE
scheme that supports the coefficient encoding.</p><p>Example:</p><pre tabindex=0><code>#generator = #poly.polynomial&lt;1 + x**1024&gt;
#ring = #poly.ring&lt;cmod=65536, ideal=#generator&gt;
#coeff_encoding = #lwe.polynomial_coefficient_encoding&lt;cleartext_start=15, cleartext_bitwidth=4&gt;

%poly1 = poly.from_tensor %coeffs1 : tensor&lt;10xi16&gt; -&gt; !poly.poly&lt;#ring&gt;
%poly2 = poly.from_tensor %coeffs2 : tensor&lt;10xi16&gt; -&gt; !poly.poly&lt;#ring&gt;
%rlwe_ciphertext = tensor.from_elements %poly1, %poly2 : tensor&lt;2x!poly.poly&lt;#ring&gt;, #coeff_encoding&gt;
</code></pre><h4 id=parameters-4>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>cleartext_start</td><td style=text-align:center><code>unsigned</code></td><td></td></tr><tr><td style=text-align:center>cleartext_bitwidth</td><td style=text-align:center><code>unsigned</code></td><td></td></tr></tbody></table><h3 id=polynomialevaluationencodingattr>PolynomialEvaluationEncodingAttr</h3><p>An attribute describing encoded RLWE plaintexts via evaluations at fixed points.</p><p>Syntax:</p><pre tabindex=0><code>#lwe.polynomial_evaluation_encoding&lt;
  unsigned,   # cleartext_start
  unsigned   # cleartext_bitwidth
&gt;
</code></pre><p>A &ldquo;evaluation encoding&rdquo; of a list of integers $(v_1, \dots, v_n)$ asserts
that $f(x_1 ) = v_1, \dots, f(x_n) = v_n$ for some implicit, but fixed and
distinct choice of inputs $x_i$. The encoded values are also scaled by a
scale factor, having the same semantics as <code>bit_field_encoding</code>, but
applied entry-wise (to either the coefficient or evaluation representation).</p><p>This attribute can be used in multiple ways:</p><ul><li>On a <code>poly.poly</code>, it asserts that the polynomial has been transformed
from an evaluation tensor.</li><li>On a tensor of <code>poly.poly</code>, it asserts that the tensor is an RLWE
ciphertext for some RLWE scheme that supports the evaluation encoding.</li></ul><p>A typical workflow for the BFV/BGV schemes using this encoding would be
to apply a INTT operation to the input list of cleartexts to convert from
evaluation form to coefficient form, then encrypt the resulting polynomial
in coefficient form, then apply NTT back to the evaluation form for faster
multiplication of ciphertexts.</p><p>The points chosen are fixed to be the powers of a primitive root of unity
of the coefficient ring of the plaintext space, which allows one to use
NTT/INTT to tansform quickly between the coefficient and evaluation forms.</p><p>Example:</p><pre tabindex=0><code>#generator = #poly.polynomial&lt;1 + x**1024&gt;
// note that the cmod should be chosen so as to ensure a primitive root of
// unity exists in the multiplicative group (Z / cmod Z)^*
#ring = #poly.ring&lt;cmod=65536, ideal=#generator&gt;
#lwe_encoding = #lwe.polynomial_evaluation_encoding&lt;cleartext_start=30, cleartext_bitwidth=3&gt;

%evals = arith.constant &lt;[1, 2, 4, 5]&gt; : tensor&lt;4xi16&gt;
// TODO(https://github.com/google/heir/issues/182): fix docs
// Note no `intt` operation exists in poly yet.
%poly1 = poly.intt %evals : tensor&lt;4xi16&gt; -&gt; !poly.poly&lt;#ring, #eval_encoding&gt;
%poly2 = poly.intt %evals : tensor&lt;4xi16&gt; -&gt; !poly.poly&lt;#ring, #eval_encoding&gt;
%rlwe_ciphertext = tensor.from_elements %poly1, %poly2 : tensor&lt;2x!poly.poly&lt;#ring, #eval_encoding&gt;&gt;
</code></pre><h4 id=parameters-5>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>cleartext_start</td><td style=text-align:center><code>unsigned</code></td><td></td></tr><tr><td style=text-align:center>cleartext_bitwidth</td><td style=text-align:center><code>unsigned</code></td><td></td></tr></tbody></table><h2 id=lwe-types>LWE types</h2><h3 id=lweciphertexttype>LWECiphertextType</h3><p>A type for LWE ciphertexts</p><p>Syntax:</p><pre tabindex=0><code>!lwe.lwe_ciphertext&lt;
  ::mlir::Attribute,   # encoding
  LWEParamsAttr   # lwe_params
&gt;
</code></pre><p>A type for LWE ciphertexts.</p><p>This type keeps track of the plaintext integer encoding for the LWE
Ciphertext to ensure proper decoding after decryption. It also keeps track
of the ring where the LWE ciphertext is defined, which provides information
on the ciphertext shape and the ring operations used in LWE operations.</p><h4 id=parameters-6>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>encoding</td><td style=text-align:center><code>::mlir::Attribute</code></td><td></td></tr><tr><td style=text-align:center>lwe_params</td><td style=text-align:center><code>LWEParamsAttr</code></td><td></td></tr></tbody></table><h3 id=lweplaintexttype>LWEPlaintextType</h3><p>A type for LWE plaintexts</p><p>Syntax:</p><pre tabindex=0><code>!lwe.lwe_plaintext&lt;
  ::mlir::Attribute   # encoding
&gt;
</code></pre><p>A type for LWE plaintexts.</p><p>This type keeps track of the plaintext integer encoding for the LWE
plaintext before it is encrypted.</p><h4 id=parameters-7>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>encoding</td><td style=text-align:center><code>::mlir::Attribute</code></td><td></td></tr></tbody></table><h2 id=lwe-ops>LWE ops</h2><h3 id=lweencode-heirlweencodeop><code>lwe.encode</code> (heir::lwe::EncodeOp)</h3><p><em>Encode an integer to yield an LWE plaintext</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.encode` $plaintext attr-dict `:` type($plaintext) `to` type($output)
</code></pre><p>Encode an integer to yield an LWE plaintext.</p><p>This op uses a an encoding attribute to encode the bits of the integer into
an LWE plaintext value that can then be encrypted.</p><p>Examples:</p><pre tabindex=0><code>%Y = lwe.encode %value {encoding = #enc}: i1 to !lwe.lwe_plaintext&lt;encoding = #enc, ring = #ring&gt;
</code></pre><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>encoding</code></td><td>::mlir::Attribute</td><td>An attribute describing encoded LWE plaintexts using bit fields. or An attribute describing unspecified bit field encodings.</td></tr></table><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>plaintext</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for LWE plaintexts</td></tr></tbody></table><h3 id=lwetrivial_encrypt-heirlwetrivialencryptop><code>lwe.trivial_encrypt</code> (heir::lwe::TrivialEncryptOp)</h3><p><em>Create a trivial encryption of a plaintext.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `lwe.trivial_encrypt` operands attr-dict `:`  qualified(type(operands)) `to` qualified(type(results))
</code></pre><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-1>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>params</code></td><td>::mlir::heir::lwe::LWEParamsAttr</td><td></td></tr></table><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>A type for LWE plaintexts</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for LWE ciphertexts</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-cabcacfc9b7cbac2ba4f6fc790a84b68>5 - PolyExt</h1><p>The PolyExt dialect is a place for &ldquo;external&rdquo; operations on
<code>mlir::heir::polynomial::Polynomial</code>.</p><h2 id=polyext-ops>PolyExt ops</h2><h3 id=poly_extcmod_switch-heirpoly_extcmodswitchop><code>poly_ext.cmod_switch</code> (heir::poly_ext::CModSwitchOp)</h3><p><em>Move polynomial into a ring with different <code>cmod</code> by scaling polynomial coefficients proportionally</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `poly_ext.cmod_switch` $x attr-dict `:` type($x) `-&gt;` type($output)
</code></pre><p><code>poly_ext.cmod_switch</code> &ldquo;moves&rdquo; polynomial $x$ from ring $Z/QZ[X]/(f(x))$ to the ring $Z/qZ[X]/(f(x))$.
The move is done by scaling the polynomial coefficients by $q/Q$ and &ldquo;rounding&rdquo; so input and output coufficients are congruent modulo <code>congruence_modulus</code> $t$.
The resulting polynomial $\tilde{x} \approx (q/Q)x$ and $\tilde{x} \equiv x \mod t$.</p><p>Traits: AlwaysSpeculatableImplTrait, Elementwise, Scalarizable, Tensorizable, Vectorizable</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>congruence_modulus</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr></table><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>x</code></td><td>polynomial-like</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>polynomial-like</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-b18fea903e4651113f5317788f1491e1>6 - Polynomial</h1><p>The Polynomial dialect defines single-variable polynomial types and
operations.</p><p>The simplest use of this dialect is to do math in a polynomial ring <code>R[x]</code>,
where <code>R</code> is another MLIR integer type like <code>u32</code>, and lower to <code>arith</code>.</p><p>More generally, this dialect represent polynomial operations in a quotient
polynomial ring <code>Z/qZ[X]/(f(x))</code> for some integer <code>q</code> and polynomial <code>f(x)</code>.
Polyomials <code>p(x), q(x)</code> are equal in this ring if they have the same remainder
when dividing by <code>f(x)</code>. The canonical representative for a polynomial <code>p(x)</code>
is has degree less than <code>deg(f(x))</code>. When a modulus is given, ring operations
are polynomial addition and multiplication performed with reductions modulo
<code>f(x)</code> and <code>q</code>.</p><h2 id=polynomial-attributes>Polynomial attributes</h2><h3 id=polynomialattr>PolynomialAttr</h3><p>An attribute containing a single-variable polynomial.</p><p>#poly = #polynomial.poly&lt;x**1024 + 1></p><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>Polynomial</code></td><td></td></tr></tbody></table><h3 id=ringattr>RingAttr</h3><p>An attribute specifying a ring.</p><p>An attribute specifying a polynomial quotient ring with integer
coefficients, $\mathbb{Z}/n\mathbb{Z}[x] / (p(x))$.</p><p><code>cmod</code> is the coefficient modulus $n$, and <code>ideal</code> is the ring ideal
$(p(x))$. Because all ideals in a single-variable polynomial ring are
principal, the ideal is defined by a single polynomial.</p><p>#ring = #polynomial.ring&lt;cmod=1234, ideal=#polynomial.polynomial&lt;x**1024 + 1&#187;</p><h4 id=parameters-1>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>cmod</td><td style=text-align:center><code>IntegerAttr</code></td><td></td></tr><tr><td style=text-align:center>ideal</td><td style=text-align:center><code>Polynomial</code></td><td></td></tr></tbody></table><h2 id=polynomial-types>Polynomial types</h2><h3 id=polynomialtype>PolynomialType</h3><p>An element of a polynomial quotient ring</p><p>Syntax:</p><pre tabindex=0><code>!polynomial.polynomial&lt;
  ::mlir::heir::polynomial::RingAttr,   # ring
  Attribute   # encoding
&gt;
</code></pre><p>A type for polynomials in a polynomial quotient ring.</p><h4 id=parameters-2>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>ring</td><td style=text-align:center><code>::mlir::heir::polynomial::RingAttr</code></td><td>An attribute specifying a ring.</td></tr><tr><td style=text-align:center>encoding</td><td style=text-align:center><code>Attribute</code></td><td></td></tr></tbody></table><h2 id=polynomial-ops>Polynomial ops</h2><h3 id=polynomialadd-heirpolynomialaddop><code>polynomial.add</code> (heir::polynomial::AddOp)</h3><p><em>Addition operation between polynomials.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `polynomial.add` `(` operands `)` attr-dict `:` qualified(type($output))
</code></pre><p>Traits: AlwaysSpeculatableImplTrait, Commutative, Elementwise, SameOperandsAndResultType, Scalarizable, Tensorizable, Vectorizable</p><p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>polynomial-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>polynomial-like</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>polynomial-like</td></tr></tbody></table><h3 id=polynomialconstant-heirpolynomialconstantop><code>polynomial.constant</code> (heir::polynomial::ConstantOp)</h3><p><em>Define a constant polynomial via an attribute.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `polynomial.constant` $input attr-dict `:` qualified(type($output))
</code></pre><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>input</code></td><td>::mlir::heir::polynomial::PolynomialAttr</td><td>An attribute containing a single-variable polynomial.</td></tr></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>An element of a polynomial quotient ring</td></tr></tbody></table><h3 id=polynomialfrom_tensor-heirpolynomialfromtensorop><code>polynomial.from_tensor</code> (heir::polynomial::FromTensorOp)</h3><p><em>Creates a polynomial from integer coefficients stored in a tensor.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `polynomial.from_tensor` $input attr-dict `:` type($input) `-&gt;` qualified(type($output))
</code></pre><p><code>polynomial.from_tensor</code> creates a polynomial value from a tensor of coefficients.
The input tensor must list the coefficients in degree-increasing order.</p><p>The input one-dimensional tensor may have size at most the degree of the
ring&rsquo;s ideal generator polynomial, with smaller dimension implying that
all higher-degree terms have coefficient zero.</p><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>ranked tensor of integer values</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>An element of a polynomial quotient ring</td></tr></tbody></table><h3 id=polynomialleading_term-heirpolynomialleadingtermop><code>polynomial.leading_term</code> (heir::polynomial::LeadingTermOp)</h3><p><em>Compute the leading term of the polynomial.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `polynomial.leading_term` operands attr-dict `:` qualified(type($input)) `-&gt;` `(` type($degree) `,` type($coefficient) `)`
</code></pre><p>The degree of a polynomial is the largest $k$ for which the coefficient
$a_k$ of $x^k$ is nonzero. The leading term is the term $a_k x^k$, which
this op represents as a pair of results.</p><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>An element of a polynomial quotient ring</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>degree</code></td><td>index</td></tr><tr><td style=text-align:center><code>coefficient</code></td><td>integer</td></tr></tbody></table><h3 id=polynomialmonomial_mul-heirpolynomialmonomialmulop><code>polynomial.monomial_mul</code> (heir::polynomial::MonomialMulOp)</h3><p><em>Multiply a polynomial by a monic monomial.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `polynomial.monomial_mul` operands attr-dict `:`  `(` type(operands) `)` `-&gt;` type(results)
</code></pre><p>In the ring of polynomials mod $x^n - 1$, <code>monomial_mul</code> can be interpreted
as a cyclic shift of the coefficients of the polynomial. For some rings,
this results in optimized lowerings that involve rotations and rescaling
of the coefficients of the input.</p><p>Interfaces: InferTypeOpInterface</p><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>An element of a polynomial quotient ring</td></tr><tr><td style=text-align:center><code>monomialDegree</code></td><td>index</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>An element of a polynomial quotient ring</td></tr></tbody></table><h3 id=polynomialmonomial-heirpolynomialmonomialop><code>polynomial.monomial</code> (heir::polynomial::MonomialOp)</h3><p><em>Create a polynomial that consists of a single monomial.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `polynomial.monomial` operands attr-dict `:`  `(` type(operands) `)` `-&gt;` type(results)
</code></pre><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>coefficient</code></td><td>integer</td></tr><tr><td style=text-align:center><code>degree</code></td><td>index</td></tr></tbody></table><h4 id=results-5>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>An element of a polynomial quotient ring</td></tr></tbody></table><h3 id=polynomialmul-heirpolynomialmulop><code>polynomial.mul</code> (heir::polynomial::MulOp)</h3><p><em>Multiplication operation between polynomials.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `polynomial.mul` `(` operands `)` attr-dict `:` qualified(type($output))
</code></pre><p>Traits: AlwaysSpeculatableImplTrait, Commutative, Elementwise, SameOperandsAndResultType, Scalarizable, Tensorizable, Vectorizable</p><p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>polynomial-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>polynomial-like</td></tr></tbody></table><h4 id=results-6>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>polynomial-like</td></tr></tbody></table><h3 id=polynomialmul_scalar-heirpolynomialmulscalarop><code>polynomial.mul_scalar</code> (heir::polynomial::MulScalarOp)</h3><p><em>Multiplication by a scalar of the field.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `polynomial.mul_scalar` operands attr-dict `:` qualified(type($polynomial)) `,` type($scalar)
</code></pre><p>Traits: Elementwise, Scalarizable, Tensorizable, Vectorizable</p><p>Interfaces: InferTypeOpInterface</p><h4 id=operands-6>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>polynomial</code></td><td>polynomial-like</td></tr><tr><td style=text-align:center><code>scalar</code></td><td>integer</td></tr></tbody></table><h4 id=results-7>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>polynomial-like</td></tr></tbody></table><h3 id=polynomialsub-heirpolynomialsubop><code>polynomial.sub</code> (heir::polynomial::SubOp)</h3><p><em>Subtraction operation between polynomials.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `polynomial.sub` `(` operands `)` attr-dict `:` qualified(type($output))
</code></pre><p>Traits: AlwaysSpeculatableImplTrait, Elementwise, SameOperandsAndResultType, Scalarizable, Tensorizable, Vectorizable</p><p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-7>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>polynomial-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>polynomial-like</td></tr></tbody></table><h4 id=results-8>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>polynomial-like</td></tr></tbody></table><h3 id=polynomialto_tensor-heirpolynomialtotensorop><code>polynomial.to_tensor</code> (heir::polynomial::ToTensorOp)</h3><p><em>Creates a tensor containing the coefficients of a polynomial.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `polynomial.to_tensor` $input attr-dict `:` qualified(type($input)) `-&gt;` type($output)
</code></pre><p><code>polynomial.to_tensor</code> creates a tensor value containing the coefficients of the
input polynomial. The output tensor contains the coefficients in
degree-increasing order.</p><p>Operations that act on the coefficients of a polynomial, such as extracting
a specific coefficient or extracting a range of coefficients, should be
implemented by composing <code>to_tensor</code> with the relevant <code>tensor</code> dialect
ops.</p><p>The output tensor has shape equal to the degree of the ring&rsquo;s ideal
generator polynomial, including zeroes.</p><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-8>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>An element of a polynomial quotient ring</td></tr></tbody></table><h4 id=results-9>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>ranked tensor of integer values</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-f7ffac8ba93b73b8a62e185ec8643d63>7 - Secret</h1><p>Secret is a dialect for computations that operate on encrypted data.</p><p>Secret is intended to serve as a scheme-agnostic front-end for the HEIR
ecosystem of dialects. It is supposed to be fully interoperable with the
rest of MLIR via secret.generic, while lower-level HEIR dialects would have
custom types for arithmetic on secret integers of various bit widths.</p><h2 id=secret-types>Secret types</h2><h3 id=secrettype>SecretType</h3><p>A secret value</p><p>Syntax:</p><pre tabindex=0><code>!secret.secret&lt;
  Type   # valueType
&gt;
</code></pre><p>A generic wrapper around another MLIR type, representing an encrypted value
but not specifying the manner of encryption. This is useful in HEIR because
the compiler may choose various details of the FHE scheme based on the
properties of the input program, the backend target hardware, and cost
models of the various passes.</p><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>valueType</td><td style=text-align:center><code>Type</code></td><td></td></tr></tbody></table><h2 id=secret-ops>Secret ops</h2><h3 id=secretconceal-heirsecretconcealop><code>secret.conceal</code> (heir::secret::ConcealOp)</h3><p><em>Convert a non-secret value into a secret</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `secret.conceal` $cleartext attr-dict `:` type($cleartext) `-&gt;` type($output)
</code></pre><p>Convert a value to a secret containing the same value.</p><p>This op represents a scheme-agnostic encryption operation, as well as a
&ldquo;trivial encryption&rdquo; operation which is needed for some FHE schemes. This
op is also useful for type materialization in the dialect conversion
framework.</p><p>Examples:</p><pre tabindex=0><code>%Y = secret.conceal %value : i32 -&gt; !secret.secret&lt;i32&gt;
</code></pre><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cleartext</code></td><td>any type</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A secret value</td></tr></tbody></table><h3 id=secretgeneric-heirsecretgenericop><code>secret.generic</code> (heir::secret::GenericOp)</h3><p><em>Lift a plaintext computation to operate on secrets.</em></p><p><code>secret.generic</code> lifts a plaintext computation to operate on one or more
secrets. The lifted computation is represented as a region containing a
single block terminated by <code>secret.yield</code>. The arguments of the <code>secret.generic</code>
may include one or more <code>!secret.secret</code> types. The arguments of the block
in the op&rsquo;s body correspond to the underlying plaintext types of the secrets.</p><p>Basic examples:</p><p>Add two secret integers together</p><pre tabindex=0><code>%Z = secret.generic ins(%X, %Y : !secret.secret&lt;i32&gt;, !secret.secret&lt;i32&gt;) {
  ^bb0(%x: i32, %y: i32) :
    %z = arith.addi %x, %y: i32
    secret.yield %z : i32
  } -&gt; (!secret.secret&lt;i32&gt;)
</code></pre><p>Add a secret value with a plaintext value. I.e., not all arguments to the
op need be secret.</p><pre tabindex=0><code>%Z = secret.generic ins(%X, %Y : i32, !secret.secret&lt;i32&gt;) {
  ^bb0(%x: i32, %y: i32) :
    %z = arith.addi %x, %y: i32
    secret.yield %z : i32
  } -&gt; (!secret.secret&lt;i32&gt;)
</code></pre><p>Traits: IsolatedFromAbove, SingleBlock, SingleBlockImplicitTerminator<yieldop></p><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>results</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=secretreveal-heirsecretrevealop><code>secret.reveal</code> (heir::secret::RevealOp)</h3><p><em>Convert a secret value into a non-secret</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `secret.reveal` $input attr-dict `:` type($input) `-&gt;` type($cleartext)
</code></pre><p>Convert a secret into a non-secret containing the same value.</p><p>This op represents a scheme-agnostic decryption operation. This op is also
useful for target materialization in the dialect conversion framework.</p><p>Examples:</p><pre tabindex=0><code>%Y = secret.reveal %secret_value : !secret.secret&lt;i32&gt; -&gt; i32
</code></pre><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>A secret value</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cleartext</code></td><td>any type</td></tr></tbody></table><h3 id=secretyield-heirsecretyieldop><code>secret.yield</code> (heir::secret::YieldOp)</h3><p><em>Secret yield operation</em></p><p><code>secret.yield</code> is a special terminator operation for blocks inside regions
in <code>secret</code> generic ops. It returns the cleartext value of the
corresponding private computation to the immediately enclosing <code>secret</code>
generic op.</p><p>Traits: AlwaysSpeculatableImplTrait, HasParent<genericop>, ReturnLike, Terminator</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), RegionBranchTerminatorOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>values</code></td><td>variadic of any type</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-678c1db0f9b2ed4c9d43b790f890bea0>8 - TfheRust</h1><p>The <code>thfe_rust</code> dialect is an exit dialect for generating rust code against the tfhe-rs library API.</p><p>See <a href=https://github.com/zama-ai/tfhe-rs>https://github.com/zama-ai/tfhe-rs</a></p><h2 id=tfherust-types>TfheRust types</h2><h3 id=encryptedint8type>EncryptedInt8Type</h3><p>An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type.</p><p>Syntax: <code>!tfhe_rust.ei8</code></p><h3 id=encryptedint16type>EncryptedInt16Type</h3><p>An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type.</p><p>Syntax: <code>!tfhe_rust.ei16</code></p><h3 id=encryptedint32type>EncryptedInt32Type</h3><p>An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type.</p><p>Syntax: <code>!tfhe_rust.ei32</code></p><h3 id=encryptedint64type>EncryptedInt64Type</h3><p>An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type.</p><p>Syntax: <code>!tfhe_rust.ei64</code></p><h3 id=encryptedint128type>EncryptedInt128Type</h3><p>An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type.</p><p>Syntax: <code>!tfhe_rust.ei128</code></p><h3 id=encryptedint256type>EncryptedInt256Type</h3><p>An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type.</p><p>Syntax: <code>!tfhe_rust.ei256</code></p><h3 id=encrypteduint2type>EncryptedUInt2Type</h3><p>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type.</p><p>Syntax: <code>!tfhe_rust.eui2</code></p><h3 id=encrypteduint3type>EncryptedUInt3Type</h3><p>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type.</p><p>Syntax: <code>!tfhe_rust.eui3</code></p><h3 id=encrypteduint4type>EncryptedUInt4Type</h3><p>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type.</p><p>Syntax: <code>!tfhe_rust.eui4</code></p><h3 id=encrypteduint8type>EncryptedUInt8Type</h3><p>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type.</p><p>Syntax: <code>!tfhe_rust.eui8</code></p><h3 id=encrypteduint10type>EncryptedUInt10Type</h3><p>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type.</p><p>Syntax: <code>!tfhe_rust.eui10</code></p><h3 id=encrypteduint12type>EncryptedUInt12Type</h3><p>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type.</p><p>Syntax: <code>!tfhe_rust.eui12</code></p><h3 id=encrypteduint14type>EncryptedUInt14Type</h3><p>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type.</p><p>Syntax: <code>!tfhe_rust.eui14</code></p><h3 id=encrypteduint16type>EncryptedUInt16Type</h3><p>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type.</p><p>Syntax: <code>!tfhe_rust.eui16</code></p><h3 id=encrypteduint32type>EncryptedUInt32Type</h3><p>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type.</p><p>Syntax: <code>!tfhe_rust.eui32</code></p><h3 id=encrypteduint64type>EncryptedUInt64Type</h3><p>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type.</p><p>Syntax: <code>!tfhe_rust.eui64</code></p><h3 id=encrypteduint128type>EncryptedUInt128Type</h3><p>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type.</p><p>Syntax: <code>!tfhe_rust.eui128</code></p><h3 id=encrypteduint256type>EncryptedUInt256Type</h3><p>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type.</p><p>Syntax: <code>!tfhe_rust.eui256</code></p><h3 id=lookuptabletype>LookupTableType</h3><p>A univariate lookup table used for programmable bootstrapping.</p><p>Syntax: <code>!tfhe_rust.lookup_table</code></p><h3 id=serverkeytype>ServerKeyType</h3><p>The server key required to perform homomorphic operations.</p><p>Syntax: <code>!tfhe_rust.server_key</code></p><h2 id=tfherust-ops>TfheRust ops</h2><h3 id=tfhe_rustadd-heirtfhe_rustaddop><code>tfhe_rust.add</code> (heir::tfhe_rust::AddOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust.add` operands attr-dict `:` `(` type(operands) `)` `-&gt;` type(results)
</code></pre><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The server key required to perform homomorphic operations.</td></tr><tr><td style=text-align:center><code>lhs</code></td><td>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type.</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type.</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type.</td></tr></tbody></table><h3 id=tfhe_rustapply_lookup_table-heirtfhe_rustapplylookuptableop><code>tfhe_rust.apply_lookup_table</code> (heir::tfhe_rust::ApplyLookupTableOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust.apply_lookup_table` operands attr-dict `:` `(` type(operands) `)` `-&gt;` type(results)
</code></pre><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The server key required to perform homomorphic operations.</td></tr><tr><td style=text-align:center><code>input</code></td><td>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type.</td></tr><tr><td style=text-align:center><code>lookupTable</code></td><td>A univariate lookup table used for programmable bootstrapping.</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type.</td></tr></tbody></table><h3 id=tfhe_rustcreate_trivial-heirtfhe_rustcreatetrivialop><code>tfhe_rust.create_trivial</code> (heir::tfhe_rust::CreateTrivialOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust.create_trivial` operands attr-dict `:` `(` type(operands) `)` `-&gt;` type(results)
</code></pre><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The server key required to perform homomorphic operations.</td></tr><tr><td style=text-align:center><code>value</code></td><td>integer</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type.</td></tr></tbody></table><h3 id=tfhe_rustgenerate_lookup_table-heirtfhe_rustgeneratelookuptableop><code>tfhe_rust.generate_lookup_table</code> (heir::tfhe_rust::GenerateLookupTableOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust.generate_lookup_table` operands attr-dict `:` `(` type(operands) `)` `-&gt;` type(results)
</code></pre><p>Interfaces: InferTypeOpInterface</p><h4 id=attributes>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>truthTable</code></td><td>::mlir::IntegerAttr</td><td>An Attribute containing a integer value</td></tr></table><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The server key required to perform homomorphic operations.</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lookupTable</code></td><td>A univariate lookup table used for programmable bootstrapping.</td></tr></tbody></table><h3 id=tfhe_rustscalar_left_shift-heirtfhe_rustscalarleftshiftop><code>tfhe_rust.scalar_left_shift</code> (heir::tfhe_rust::ScalarLeftShiftOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `tfhe_rust.scalar_left_shift` operands attr-dict `:` `(` type(operands) `)` `-&gt;` type(results)
</code></pre><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>serverKey</code></td><td>The server key required to perform homomorphic operations.</td></tr><tr><td style=text-align:center><code>ciphertext</code></td><td>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type.</td></tr><tr><td style=text-align:center><code>shiftAmount</code></td><td>8-bit integer</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint2 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint3 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint4 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint8 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint10 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint12 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint14 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint16 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint32 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint64 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint128 type. or An encrypted unsigned integer corresponding to tfhe-rs&rsquo;s FHEUint256 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt8 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt16 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt32 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt64 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt128 type. or An encrypted signed integer corresponding to tfhe-rs&rsquo;s FHEInt256 type.</td></tr></tbody></table></div></main></div></div><footer class="td-footer row d-print-none"><div class=container-fluid><div class="row mx-md-2"><div class="col-6 col-sm-4 text-xs-center order-sm-2"></div><div class="col-6 col-sm-4 text-end text-xs-center order-sm-3"><ul class=td-footer__links-list><li class=td-footer__links-item data-bs-toggle=tooltip title=GitHub aria-label=GitHub><a target=_blank rel=noopener href=https://github.com/google/heir aria-label=GitHub><i class="fab fa-github"></i></a></li></ul></div><div class="td-footer__copyright-etc col-12 col-sm-4 text-center py-2 order-sm-2"><span>&copy; 2023 The HEIR Authors All Rights Reserved</span>
<span class=ms-1><a href=https://policies.google.com/privacy target=_blank rel=noopener>Privacy Policy</a></span></div></div></div></footer></div><script src=/js/main.min.027d75d71824837bee74c12a7806c5fe51249c1ca7accc27553a251a75cdb3a4.js integrity="sha256-An111xgkg3vudMEqeAbF/lEknBynrMwnVTolGnXNs6Q=" crossorigin=anonymous></script>
<script defer src=/js/click-to-copy.min.f724d3de49218995223b7316aa2e53e2b34bf42026bf399ebb21bb02212402d1.js integrity="sha256-9yTT3kkhiZUiO3MWqi5T4rNL9CAmvzmeuyG7AiEkAtE=" crossorigin=anonymous></script>
<script src=/js/tabpane-persist.js></script></body></html>